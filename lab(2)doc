import numpy as np
import time
from numpy.ctypeslib import ndpointer
import ctypes

# Параметры задачи
N = 2048  # Размер матрицы
TRIALS = 3  # Количество испытаний
INITIAL_BLOCK_SIZE = 128  # Начальный размер блока

# Генерация случайных комплексных матриц
def generate_matrices():
    print(f"Генерация комплексных матриц {N}x{N}...")
    np.random.seed(42)
    real_part = np.random.rand(N, N).astype(np.float32)
    imag_part = np.random.rand(N, N).astype(np.float32)
    A = real_part + 1j * imag_part
    B = real_part.T - 1j * imag_part.T
    return A, B

# Оптимизированный метод с автоматической настройкой
def high_performance_matmul(A, B, block_size):
    n = A.shape[0]
    C = np.zeros((n, n), dtype=np.complex64)
    
    for i in range(0, n, block_size):
        for j in range(0, n, block_size):
            # Предварительное выделение блока результата
            C_block = np.zeros((min(block_size, n-i), 
                              min(block_size, n-j)), 
                              dtype=np.complex64)
            
            for k in range(0, n, block_size):
                A_block = A[i:i+block_size, k:k+block_size]
                B_block = B[k:k+block_size, j:j+block_size]
                C_block += np.matmul(A_block, B_block)
            
            C[i:i+block_size, j:j+block_size] = C_block
    return C

# BLAS через numpy.dot (MKL)
def blas_matmul(A, B):
    return np.dot(A, B)

# Тестирование производительности
def test_performance(method, A, B, method_name, **kwargs):
    print(f"\nТестирование метода: {method_name}")
    
    # Прогрев
    warm_up_size = min(64, N)
    method(A[:warm_up_size, :warm_up_size], 
          B[:warm_up_size, :warm_up_size], **kwargs)
    
    times = []
    for _ in range(TRIALS):
        start = time.perf_counter()
        C = method(A, B, **kwargs)
        times.append(time.perf_counter() - start)
        assert C.shape == (N, N), "Некорректный размер результата"
    
    avg_time = np.mean(times)
    complexity = 2 * N**3  # 2n^3 операций для комплексных чисел
    mflops = (complexity / avg_time) / 1e6
    
    print(f"Среднее время ({TRIALS} испытаний): {avg_time:.2f} сек")
    print(f"Производительность: {mflops:.2f} MFlops")
    return mflops

def main():
    A, B = generate_matrices()
    
    print(f"\nСравнение методов перемножения комплексных матриц {N}x{N}")
    
    # 1. Сначала тестируем BLAS для получения эталона
    print("\nЭталонный тест BLAS...")
    blas_mflops = test_performance(blas_matmul, A, B, "BLAS (numpy.dot)")
    target_mflops = blas_mflops * 0.3
    print(f"\nЦелевая производительность (30% от BLAS): {target_mflops:.2f} MFlops")
    
    # 2. Тестируем оптимизированный метод с автоматической настройкой
    print("\nТестирование оптимизированного метода с автоматической настройкой...")
    
    best_mflops = 0
    best_block_size = INITIAL_BLOCK_SIZE
    
    # Перебираем размеры блоков от большего к меньшему
    for block_size in [256, 128, 64, 32]:
        current_mflops = test_performance(high_performance_matmul, A, B, 
                                        f"Оптимизированный (block={block_size})", 
                                        block_size=block_size)
        
        if current_mflops > best_mflops:
            best_mflops = current_mflops
            best_block_size = block_size
            
        # Если достигли цели, останавливаемся
        if best_mflops >= target_mflops:
            break
    
    # 3. Финальное тестирование с лучшими параметрами
    print(f"\nФинальный тест с оптимальным размером блока ({best_block_size})...")
    final_mflops = test_performance(high_performance_matmul, A, B, 
                                  "Оптимизированный (финальный)", 
                                  block_size=best_block_size)
    
    # Результаты
    print("\nИтоговые результаты:")
    print(f"BLAS (numpy.dot): {blas_mflops:.2f} MFlops")
    print(f"Оптимизированный метод: {final_mflops:.2f} MFlops")
    
    ratio = final_mflops / blas_mflops
    print(f"\nОтношение производительности: {ratio:.1%}")
    
    if ratio >= 0.3:
        print("УСПЕХ: Оптимизированный метод удовлетворяет требованию (≥30% от BLAS)")
    else:
        print("НЕУДАЧА: Требование не выполнено")

if __name__ == "__main__":
    main()
